#ifndef __FLYSCENE__
#define __FLYSCENE__

// Must be included before glfw.
#include <GL/glew.h>

#include <GLFW/glfw3.h>

#include <tucano/effects/phongmaterialshader.hpp>
#include <tucano/mesh.hpp>
#include <tucano/shapes/camerarep.hpp>
#include <tucano/shapes/cylinder.hpp>
#include <tucano/shapes/sphere.hpp>
#include <tucano/utils/flycamera.hpp>
#include <tucano/utils/imageIO.hpp>
#include <tucano/utils/mtlIO.hpp>
#include <tucano/utils/objimporter.hpp>

class Flyscene {

public:
    Flyscene(void) = default;

    /**
     * @brief Initializes the shader effect
     * @param width Window width in pixels
     * @param height Window height in pixels
     */
    void initialize(int width, int height);

    /**
     * Repaints screen buffer.
     **/
    virtual void paintGL();

    /**
     * Perform a single simulation step.
     **/
    virtual void simulate(GLFWwindow *window);

    /**
     * Returns the pointer to the flycamera instance
     * @return pointer to flycamera
     **/
    Tucano::Flycamera *getCamera(void) { return &flycamera; }

    /**
     * @brief Add a new light source
     */
    void addLight(void) { lights.push_back(flycamera.getCenter()); }

    /**
     * @brief Create a debug ray at the current camera location and passing
     * through pixel that mouse is over
     * @param mouse_pos Mouse cursor position in pixels
     */
    void createDebugRay(const Eigen::Vector3f& origin, const Eigen::Vector3f& direction, int recursionDepth);

    void startDebugRay(const Eigen::Vector2f& mouseCoords);

    /**
     * @brief raytrace your scene from current camera position
     */
    void raytraceScene(int width = 0, int height = 0);

    /**
    * @Brief function that calculates basic shading of an intersected face
    */
    Eigen::Vector3f shadeOffFace(int faceIndex, const Eigen::Vector3f& rayDirection, const Eigen::Vector3f& hitPosition);

	std::vector<Eigen::Vector3f> boundingVectors();

    /**
     * @brief trace a single ray from the camera passing through dest
     * @param origin Ray origin
     * @param dest Other point on the ray, usually screen coordinates
     * @return a RGB color
     */
    Eigen::Vector3f traceRay(const Eigen::Vector3f &origin, const Eigen::Vector3f &dest, const int recursionDepth);

    bool doesIntersect(const Eigen::Vector3f &origin, const Eigen::Vector3f &direction,
        int &faceId, Eigen::Vector3f &hitpoint,
        Eigen::Vector3f &reflection, Eigen::Vector3f &refraction
    );

    void traceFromY(int startY, int amountY,
        Eigen::Vector3f &origin,
        vector<vector<Eigen::Vector3f>> &pixel_data,
        Eigen::Vector2i &image_size);

private:
  // A simple phong shader for rendering meshes
  Tucano::Effects::PhongMaterial phong;

  // A fly through camera
  Tucano::Flycamera flycamera;

  // the size of the image generated by ray tracing
  Eigen::Vector2i raytracing_image_size;

  // A camera representation for animating path (false means that we do not
  // render front face)
  Tucano::Shapes::CameraRep camerarep = Tucano::Shapes::CameraRep(false);

  // a frustum to represent the camera in the scene
  Tucano::Shapes::Sphere lightrep;

  // light sources for ray tracing
  vector<Eigen::Vector3f> lights;

  // Scene light represented as a camera
  Tucano::Camera scene_light;

    /// A very thin cylinder to draw a debug ray
    vector<Tucano::Shapes::Cylinder> rays;

  // Scene meshes
  Tucano::Mesh mesh;

  /// MTL materials
  vector<Tucano::Material::Mtl> materials;
};

class boundingBox {
private:
	//The indices of all the faces contained in this boundingBox
	std::vector<int> faceIndices;
	//The minimum corner of the boundingBox
	Eigen::Vector3f vmin;
	//The maximum corner of the boundingBox
	Eigen::Vector3f vmax;

	//The children of the boundingBox, either 0 or 2. Formed by splitting the box in two along its biggest side
	std::vector<boundingBox> children;

	//If we have this amount of faces in a box it shouldn't be split any further
	int baseCase = 200;

public:
	/**
	 * @brief Constructor of the boundingBox
	 * @param smallest corner
	 * @param biggest corner
	 */
	boundingBox(Eigen::Vector3f vmin, Eigen::Vector3f vmax);

	/**
	 * @brief Adds a faceIndex to the list of indices
	 * @param index of the face to be added
	 */
	void addFaceIndex(int faceIndex);

	/**
	 * @brief Stores the children boxes of this node. 
	 * @param box on the smaller side
	 * @param box on the bigger side
	 */
	void setChildren(boundingBox lowerBox, boundingBox upperBox);

	//Return the list of faceIndices of the faces contained by the boundingBox
	std::vector<int> getFaceIndices();

	Eigen::Vector3f getVmin();

	Eigen::Vector3f getVmax();

	/**
	 * @brief The function that splits the box in two on the average of the biggest side
	 * @param The used mesh as a reference "std::ref(mesh)"
	 */
	void splitBox(Tucano::Mesh& mesh);

	std::vector<boundingBox> getChildren();

	Eigen::Vector3f getCorner(int index);
};

#endif // FLYSCENE
